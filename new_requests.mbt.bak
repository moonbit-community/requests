///|
/// MoonBit Requests - Python requests-like HTTP client library
/// API 设计对齐 Python requests

///|
/// HTTP Methods
pub enum Method {
  Get
  Post
  Put
  Delete
  Head
  Options
  Patch
} derive(Show, Eq)

///|
/// Type aliases for better API readability
pub typealias Array[(String, String)] as Headers

///|
pub typealias Array[(String, String)] as Query

///|
pub typealias Array[(String, String)] as Form

///|
/// URL parsing structure
pub struct URL {
  scheme : String
  host : String
  path : String
  port : Int?
} derive(Show)

///|
/// Parse URL into components
pub fn parse_url(url : String) -> URL raise RequestError {
  guard url.find("://") is Some(scheme_end) else {
    raise RequestError::InvalidURL("Invalid URL: missing scheme")
  }
  let scheme = (url[0:scheme_end].to_string() catch {
    _ => raise RequestError::InvalidURL("Invalid scheme in URL")
  }).to_lower()
  let rest = url[scheme_end + 3:].to_string() catch {
    _ => raise RequestError::InvalidURL("Invalid URL format")
  }
  let (host_port, path) = match rest.find("/") {
    Some(path_start) =>
      (
        rest[0:path_start].to_string() catch {
          _ => raise RequestError::InvalidURL("Invalid host")
        },
        rest[path_start:].to_string() catch {
          _ => raise RequestError::InvalidURL("Invalid path")
        },
      )
    None => (rest, "/")
  }
  let (host, port) = match host_port.rev_find(":") {
    Some(colon_pos) => {
      let host = host_port[0:colon_pos].to_string() catch {
        _ => raise RequestError::InvalidURL("Invalid host part")
      }
      let port_str = host_port[colon_pos + 1:].to_string() catch {
        _ => raise RequestError::InvalidURL("Invalid port part")
      }
      let port = parse_int_option(port_str)
      (host, port)
    }
    None => {
      let default_port = match scheme {
        "http" => Some(80)
        "https" => Some(443)
        _ => None
      }
      (host_port, default_port)
    }
  }
  URL::{ scheme, host, path, port }
}

///|
/// Individual Cookie
pub struct Cookie {
  name : String
  value : String
  domain : String?
  path : String
  secure : Bool
  http_only : Bool
  max_age_s : Int?
  expires_raw : String?
} derive(Show)

///|
/// Cookie Jar for storing and managing cookies
pub struct CookieJar {
  mut items : Array[Cookie]
} derive(Show)

///|
/// CookieJar methods
pub fn CookieJar::new() -> CookieJar {
  CookieJar::{ items: [] }
}

///|
pub fn CookieJar::set(self : CookieJar, name : String, value : String) -> Unit {
  // Simple host-only cookie
  self.upsert(Cookie::{
    name,
    value,
    domain: None,
    path: "/",
    secure: false,
    http_only: false,
    max_age_s: None,
    expires_raw: None,
  })
}

///|
pub fn CookieJar::get(self : CookieJar, name : String) -> String? {
  for cookie in self.items {
    if cookie.name == name {
      return Some(cookie.value)
    }
  }
  None
}

///|
pub fn CookieJar::upsert(self : CookieJar, cookie : Cookie) -> Unit {
  // Find and replace existing cookie or add new one
  let mut found = false
  for i = 0; i < self.items.length(); i = i + 1 {
    let existing = self.items[i]
    if existing.name == cookie.name &&
      existing.domain == cookie.domain &&
      existing.path == cookie.path {
      self.items[i] = cookie
      found = true
      break
    }
  }
  if not(found) {
    self.items.push(cookie)
  }
}

///|
pub fn CookieJar::merge(self : CookieJar, other : CookieJar) -> Unit {
  for cookie in other.items {
    self.upsert(cookie)
  }
}

///|
pub fn CookieJar::to_header_for(
  self : CookieJar,
  url : URL,
) -> (String, String)? {
  let applicable_cookies = self.items
    .filter(fn(cookie) {
      // Check secure flag
      if cookie.secure && url.scheme != "https" {
        return false
      }

      // Check domain match
      let domain_match = match cookie.domain {
        None => true // Host-only cookie matches any request to same host
        Some(domain) => {
          let domain_lower = domain.to_lower()
          let host_lower = url.host.to_lower()
          if string_starts_with(domain_lower, ".") {
            // Domain cookie
            let domain_suffix = domain_lower[1:].to_string() catch { _ => "" }
            string_ends_with(host_lower, domain_suffix) &&
            (
              host_lower == domain_suffix ||
              string_ends_with(host_lower, "." + domain_suffix)
            )
          } else {
            // Exact domain match
            host_lower == domain_lower
          }
        }
      }
      if not(domain_match) {
        return false
      }

      // Check path match
      string_starts_with(url.path, cookie.path)
    })
    .map(fn(cookie) { (cookie.name, cookie.value) })
  if applicable_cookies.is_empty() {
    None
  } else {
    let cookie_string = applicable_cookies
      .map(fn(pair) { pair.0 + "=" + pair.1 })
      .join("; ")
    Some(("Cookie", cookie_string))
  }
}

///|
/// Error types
pub suberror RequestError {
  HTTPError(Int, String, String) // status, reason, url
  Timeout(String)
  ConnectionError(String)
  InvalidURL(String)
} derive(Show)

///|
/// HTTP Response structure
pub struct Response {
  status_code : Int
  reason : String
  headers : Headers
  cookies : CookieJar
  url : String
  history : Array[Response]
  content : Bytes
} derive(Show)

///|
/// Response methods
pub fn Response::text(self : Response) -> String {
  @encoding.decode(self.content, encoding=UTF8) catch {
    _ => ""
  }
}

///|
pub fn Response::json(self : Response) -> Json raise {
  let text = self.text()
  @json.parse(text)
}

///|
pub fn Response::ok(self : Response) -> Bool {
  self.status_code >= 200 && self.status_code < 300
}

///|
pub fn Response::raise_for_status(self : Response) -> Unit raise RequestError {
  if self.status_code >= 400 {
    raise RequestError::HTTPError(self.status_code, self.reason, self.url)
  }
}

///|
pub fn Response::get_content_chunks(
  self : Response,
  chunk_size : Int,
) -> Array[Bytes] {
  let total = self.content.length()
  let chunks = []
  let mut offset = 0
  while offset < total {
    let end = if offset + chunk_size > total {
      total
    } else {
      offset + chunk_size
    }
    let chunk = self.content[offset:end].to_bytes()
    chunks.push(chunk)
    offset = end
  }
  chunks
}

///|
/// Authentication types
pub enum Auth {
  Basic(String, String) // username, password
} derive(Show)

///|
/// Request timeout specification
pub enum Timeout {
  Single(Int) // total timeout in milliseconds
  Separate(Int, Int) // (connect_timeout, read_timeout) in milliseconds
} derive(Show)

///|
/// File part for multipart uploads
pub enum FilePart {
  FromPath(String, String?, String?) // path, filename, content_type
  FromBytes(String, Bytes, String?) // filename, content, content_type
} derive(Show)

///|
pub typealias Array[(String, FilePart)] as Files

///|
/// Request options structure
pub struct RequestOptions {
  params : Query?
  headers : Headers?
  cookies : CookieJar?
  data : Form?
  json : Json?
  files : Files?
  timeout : Timeout?
  allow_redirects : Bool?
  auth : Auth?
  stream : Bool?
} derive(Show)

///|
/// Session for persistent settings
pub struct Session {
  headers : Headers
  mut cookies : CookieJar
  auth : Auth?
  allow_redirects : Bool
  timeout : Timeout?
} derive(Show)

///|
/// Session methods
pub fn Session::new() -> Session {
  Session::{
    headers: [],
    cookies: CookieJar::new(),
    auth: None,
    allow_redirects: true,
    timeout: None,
  }
}

///|
pub fn Session::close(self : Session) -> Unit {
  // Resource cleanup placeholder
}

///|
/// Session HTTP methods
pub async fn Session::get(
  self : Session,
  url : String,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data: None,
    json: None,
    files: None,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  self.request(Method::Get, url, options~)
}

///|
pub async fn Session::post(
  self : Session,
  url : String,
  data? : Form,
  json? : Json,
  files? : Files,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data,
    json,
    files,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  self.request(Method::Post, url, options~)
}

///|
pub async fn Session::put(
  self : Session,
  url : String,
  data? : Form,
  json? : Json,
  files? : Files,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data,
    json,
    files,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  self.request(Method::Put, url, options~)
}

///|
pub async fn Session::request(
  self : Session,
  method : Method,
  url : String,
  options? : RequestOptions,
) -> Response raise RequestError {
  let merged_options = self.merge_with_options(options)
  let response = perform_request(method, url, merged_options)

  // Update session cookies from response
  self.cookies.merge(response.cookies)
  response
}

///|
/// Session internal methods
fn Session::merge_with_options(
  self : Session,
  options : RequestOptions?,
) -> RequestOptions {
  let base_options = RequestOptions::{
    params: None,
    headers: Some(self.headers),
    cookies: Some(self.cookies),
    data: None,
    json: None,
    files: None,
    timeout: self.timeout,
    allow_redirects: Some(self.allow_redirects),
    auth: self.auth,
    stream: None,
  }
  match options {
    None => base_options
    Some(opts) =>
      RequestOptions::{
        params: opts.params,
        headers: merge_headers_option(base_options.headers, opts.headers),
        cookies: merge_cookies_option(base_options.cookies, opts.cookies),
        data: opts.data,
        json: opts.json,
        files: opts.files,
        timeout: opts.timeout.or(base_options.timeout),
        allow_redirects: opts.allow_redirects.or(base_options.allow_redirects),
        auth: opts.auth.or(base_options.auth),
        stream: opts.stream,
      }
  }
}

///|
/// Top-level convenience functions
pub async fn get(
  url : String,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  data? : Form,
  json? : Json,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data,
    json,
    files: None,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  perform_request(Method::Get, url, options)
}

///|
pub async fn post(
  url : String,
  data? : Form,
  json? : Json,
  files? : Files,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data,
    json,
    files,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  perform_request(Method::Post, url, options)
}

///|
pub async fn put(
  url : String,
  data? : Form,
  json? : Json,
  files? : Files,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data,
    json,
    files,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  perform_request(Method::Put, url, options)
}

///|
pub async fn request(
  method : Method,
  url : String,
  params? : Query,
  headers? : Headers,
  cookies? : CookieJar,
  data? : Form,
  json? : Json,
  files? : Files,
  timeout? : Timeout,
  allow_redirects? : Bool,
  auth? : Auth,
  stream? : Bool,
) -> Response raise RequestError {
  let options = RequestOptions::{
    params,
    headers,
    cookies,
    data,
    json,
    files,
    timeout,
    allow_redirects,
    auth,
    stream,
  }
  perform_request(method, url, options)
}

///|
/// Core request implementation
async fn perform_request(
  method : Method,
  url : String,
  options : RequestOptions,
) -> Response raise RequestError {
  // Build final URL with query parameters
  let final_url = match options.params {
    Some(params) => append_query_params(url, params)
    None => url
  }

  // Parse URL for further processing
  let parsed_url = parse_url(final_url) catch {
    _ => raise RequestError::InvalidURL("Failed to parse URL: " + final_url)
  }

  // Build headers
  let mut final_headers = options.headers.or([])

  // Add cookie header if cookies exist
  match options.cookies {
    Some(jar) =>
      match jar.to_header_for(parsed_url) {
        Some((name, value)) => final_headers.push((name, value))
        None => ()
      }
    None => ()
  }

  // Add authentication header
  match options.auth {
    Some(Auth::Basic(username, password)) => {
      let credentials = base64_encode(username + ":" + password)
      final_headers.push(("Authorization", "Basic " + credentials))
    }
    None => ()
  }

  // Build request body and content type
  let (body, content_type) = build_request_body(options)
  match content_type {
    Some(ct) => final_headers.push(("Content-Type", ct))
    None => ()
  }

  // Perform request with redirect handling
  perform_request_with_redirects(
    method, final_url, final_headers, body, options,
  )
}

///|
/// Build request body based on options
fn build_request_body(options : RequestOptions) -> (Bytes, String?) {
  match (options.data, options.json, options.files) {
    (_, _, Some(files)) => {
      // Multipart form data
      let form_data = options.data.or([])
      build_multipart_body(form_data, files)
    }
    (Some(form_data), _, _) => {
      // URL-encoded form data
      let encoded = encode_form_data(form_data)
      (encoded, Some("application/x-www-form-urlencoded"))
    }
    (_, Some(json_data), _) => {
      // JSON data
      let json_string = json_data.stringify()
      let encoded = @encoding.encode(json_string, encoding=UTF8)
      (encoded, Some("application/json"))
    }
    _ => (b"", None)
  }
}

///|
/// String utility functions
fn string_starts_with(s : String, prefix : String) -> Bool {
  s.starts_with(prefix) is Some(_)
}

///|
fn string_ends_with(s : String, suffix : String) -> Bool {
  s.ends_with(suffix) is Some(_)
}

///|
/// Utility functions
fn parse_int_option(s : String) -> Int? {
  let mut result = 0
  if s.is_empty() {
    return None
  }
  for ch in s {
    let code = ch.to_int()
    if code >= '0'.to_int() && code <= '9'.to_int() {
      result = result * 10 + (code - '0'.to_int())
    } else {
      return None
    }
  }
  Some(result)
}

///|
fn append_query_params(url : String, params : Query) -> String {
  if params.is_empty() {
    return url
  }
  let separator = if url.contains("?") { "&" } else { "?" }
  let query_string = params
    .map(fn { (key, value) => url_encode(key) + "=" + url_encode(value) })
    .join("&")
  url + separator + query_string
}

///|
fn url_encode(s : String) -> String {
  let buf = StringBuilder::new()
  for ch in s {
    let code = ch.to_int()
    if (code >= 'A'.to_int() && code <= 'Z'.to_int()) ||
      (code >= 'a'.to_int() && code <= 'z'.to_int()) ||
      (code >= '0'.to_int() && code <= '9'.to_int()) ||
      code == '-'.to_int() ||
      code == '.'.to_int() ||
      code == '_'.to_int() ||
      code == '~'.to_int() {
      buf.write_char(ch)
    } else {
      // Percent encoding
      let high = (code >> 4) & 0xF
      let low = code & 0xF
      buf.write_string("%")
      buf.write_char(hex_digit_to_char(high))
      buf.write_char(hex_digit_to_char(low))
    }
  }
  buf.to_string()
}

///|
fn hex_digit_to_char(digit : Int) -> Char {
  if digit < 10 {
    (digit + '0'.to_int()).to_char().unwrap_or('0')
  } else {
    (digit - 10 + 'A'.to_int()).to_char().unwrap_or('A')
  }
}

///|
fn encode_form_data(data : Form) -> Bytes {
  let encoded = data
    .map(fn { (key, value) => url_encode(key) + "=" + url_encode(value) })
    .join("&")
  @encoding.encode(encoded, encoding=UTF8)
}

///|
fn base64_encode(s : String) -> String {
  // Simple base64 implementation for Basic Auth
  // In production, you'd want a proper base64 implementation
  let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  let input = @encoding.encode(s, encoding=UTF8)
  let buf = StringBuilder::new()
  let mut i = 0
  while i < input.length() {
    let b1 = input[i].to_int()
    let b2 = if i + 1 < input.length() { input[i + 1].to_int() } else { 0 }
    let b3 = if i + 2 < input.length() { input[i + 2].to_int() } else { 0 }
    let chunk = (b1 << 16) | (b2 << 8) | b3
    buf.write_char(chars.get((chunk >> 18) & 63).to_char())
    buf.write_char(chars.get((chunk >> 12) & 63).to_char())
    if i + 1 < input.length() {
      buf.write_char(chars.get((chunk >> 6) & 63).to_char())
    } else {
      buf.write_char('=')
    }
    if i + 2 < input.length() {
      buf.write_char(chars.get(chunk & 63).to_char())
    } else {
      buf.write_char('=')
    }
    i = i + 3
  }
  buf.to_string()
}

///|
fn merge_headers_option(base : Headers?, extra : Headers?) -> Headers? {
  match (base, extra) {
    (None, None) => None
    (Some(b), None) => Some(b)
    (None, Some(e)) => Some(e)
    (Some(b), Some(e)) => Some(b + e)
  }
}

///|
fn merge_cookies_option(base : CookieJar?, extra : CookieJar?) -> CookieJar? {
  match (base, extra) {
    (None, None) => None
    (Some(b), None) => Some(b)
    (None, Some(e)) => Some(e)
    (Some(b), Some(e)) => {
      let merged = CookieJar::new()
      merged.merge(b)
      merged.merge(e)
      Some(merged)
    }
  }
}

///|
/// Placeholder implementations for advanced features
fn build_multipart_body(form_data : Form, files : Files) -> (Bytes, String) {
  // TODO: Implement multipart/form-data encoding
  // For now, return empty body with multipart content-type
  let boundary = "----moonbitboundary123456"
  (b"", "multipart/form-data; boundary=" + boundary)
}

///|
async fn perform_request_with_redirects(
  method : Method,
  url : String,
  headers : Headers,
  body : Bytes,
  options : RequestOptions,
) -> Response raise RequestError {
  // TODO: Implement redirect handling
  // For now, perform single request
  perform_single_request(method, url, headers, body, options)
}

///|
async fn perform_single_request(
  method : Method,
  url : String,
  headers : Headers,
  body : Bytes,
  options : RequestOptions,
) -> Response raise RequestError {
  let url_bytes = @encoding.encode(url, encoding=UTF8)
  let http_headers = headers.map(fn {
    (name, value) =>
      @http.Header(
        @encoding.encode(name, encoding=UTF8),
        @encoding.encode(value, encoding=UTF8),
      )
  })

  // Perform HTTP request based on method
  let (response, response_body) = match method {
    Get =>
      @http.get(url_bytes, headers=http_headers) catch {
        _ => raise RequestError::ConnectionError("Failed to connect to " + url)
      }
    Post =>
      @http.post(url_bytes, body, headers=http_headers) catch {
        _ => raise RequestError::ConnectionError("Failed to connect to " + url)
      }
    Put =>
      @http.put(url_bytes, body, headers=http_headers) catch {
        _ => raise RequestError::ConnectionError("Failed to connect to " + url)
      }
    _ => raise RequestError::HTTPError(501, "Method not implemented", url)
  }

  // Convert response
  let response_headers = response.headers.map(fn {
    header =>
      (
        @encoding.decode(header.name, encoding=UTF8) catch {
          _ => ""
        },
        @encoding.decode(header.value, encoding=UTF8) catch {
          _ => ""
        },
      )
  })
  let reason = @encoding.decode(response.reason, encoding=UTF8) catch {
    _ => ""
  }
  let cookie_jar = CookieJar::new()
  // TODO: Parse Set-Cookie headers

  Response::{
    status_code: response.code,
    reason,
    headers: response_headers,
    cookies: cookie_jar,
    url,
    history: [],
    content: response_body,
  }
}
